# DiDo - API diffusion
#
# API de diffusion des données de DiDo sur Internet
#
# The version of the OpenAPI document: 1.0.0
# Contact: support-dido@developpement-durable.gouv.fr
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Referentiels operations
#' @description didoscalie.Referentiels
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ExportCsvReferentielCog } \emph{ Export csv \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielGeozones } \emph{ Export csv \&quot;referentiel - geozones\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - geozones\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] > 
#' \item \emph{ @param } columns Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielPolluantsEau } \emph{ Export csv \&quot;referentiel - polluantsEau\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - polluantsEau\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielPorts } \emph{ Export csv \&quot;referentiel - ports\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - ports\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, MCA_CODE, MCA_NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } MCA_CODE character
#' \item \emph{ @param } MCA_NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielStationsAir } \emph{ Export csv \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielStationsEsu } \emph{ Export csv \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvReferentielTags } \emph{ Export csv \&quot;referentiel - tags\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;referentiel - tags\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] > 
#' \item \emph{ @param } columns Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] > 
#' \item \emph{ @param } VALUE character
#' \item \emph{ @param } DISPLAY character
#' \item \emph{ @param } TOPICS character
#' \item \emph{ @param } EUROVOC character
#' \item \emph{ @param } ECOPLANET character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportGeojsonReferentielCog } \emph{ Export geojson \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir un export geojson d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION, AREA] > 
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#'
#'
#' \item status code : 200 | Réponse avec un export geojson d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportGeojsonReferentielStationsAir } \emph{ Export geojson \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir un export geojson d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export geojson d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportGeojsonReferentielStationsEsu } \emph{ Export geojson \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir un export geojson d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION] > 
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export geojson d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielCog } \emph{ Export json \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielGeozones } \emph{ Export json \&quot;referentiel - geozones\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - geozones\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] > 
#' \item \emph{ @param } columns Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielPolluantsEau } \emph{ Export json \&quot;referentiel - polluantsEau\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - polluantsEau\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielPorts } \emph{ Export json \&quot;referentiel - ports\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - ports\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, MCA_CODE, MCA_NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } MCA_CODE character
#' \item \emph{ @param } MCA_NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielStationsAir } \emph{ Export json \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielStationsEsu } \emph{ Export json \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonReferentielTags } \emph{ Export json \&quot;referentiel - tags\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;referentiel - tags\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] > 
#' \item \emph{ @param } columns Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] > 
#' \item \emph{ @param } VALUE character
#' \item \emph{ @param } DISPLAY character
#' \item \emph{ @param } TOPICS character
#' \item \emph{ @param } EUROVOC character
#' \item \emph{ @param } ECOPLANET character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportShapefileReferentielCog } \emph{ Export shapefile \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir un export shapefile d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION, AREA] > 
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#'
#'
#' \item status code : 200 | Réponse avec un export shapefile d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportShapefileReferentielStationsAir } \emph{ Export shapefile \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir un export shapefile d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export shapefile d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportShapefileReferentielStationsEsu } \emph{ Export shapefile \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir un export shapefile d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } geo.field Enum < [LOCATION] > 
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export shapefile d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielCog } \emph{ Export xlsx \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielGeozones } \emph{ Export xlsx \&quot;referentiel - geozones\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - geozones\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] > 
#' \item \emph{ @param } columns Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielPolluantsEau } \emph{ Export xlsx \&quot;referentiel - polluantsEau\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - polluantsEau\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielPorts } \emph{ Export xlsx \&quot;referentiel - ports\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - ports\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, MCA_CODE, MCA_NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } MCA_CODE character
#' \item \emph{ @param } MCA_NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielStationsAir } \emph{ Export xlsx \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielStationsEsu } \emph{ Export xlsx \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxReferentielTags } \emph{ Export xlsx \&quot;referentiel - tags\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;referentiel - tags\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] > 
#' \item \emph{ @param } columns Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] > 
#' \item \emph{ @param } VALUE character
#' \item \emph{ @param } DISPLAY character
#' \item \emph{ @param } TOPICS character
#' \item \emph{ @param } EUROVOC character
#' \item \emph{ @param } ECOPLANET character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielCog } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - cog\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemCog} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemCog 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielGeozones } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - geozones\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - geozones\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemGeozones} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemGeozones 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielPolluantsEau } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - polluantsEau\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - polluantsEau\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemPolluantsEau} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemPolluantsEau 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielPorts } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - ports\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - ports\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemPorts} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemPorts 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielStationsAir } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - stationsAir\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemStationsAir} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemStationsAir 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielStationsEsu } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - stationsEsu\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemStationsEsu} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemStationsEsu 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdReferentielTags } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - tags\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;referentiel - tags\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemTags} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemTags 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielCog } \emph{ Pagination \&quot;referentiel - cog\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - cog\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } TYPE character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE_MILLESIME character
#' \item \emph{ @param } CODE_CURRENT character
#' \item \emph{ @param } OFFICIAL_NAME character
#' \item \emph{ @param } UPPER_NAME character
#' \item \emph{ @param } LOWER_NAME character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @param } SHAPE character
#' \item \emph{ @returnType } \link{PaginateListCog} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListCog 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielGeozones } \emph{ Pagination \&quot;referentiel - geozones\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - geozones\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] > 
#' \item \emph{ @param } columns Enum < [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] > 
#' \item \emph{ @param } ID character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } NAME character
#' \item \emph{ @returnType } \link{PaginateListGeozones} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListGeozones 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielPolluantsEau } \emph{ Pagination \&quot;referentiel - polluantsEau\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - polluantsEau\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#' \item \emph{ @returnType } \link{PaginateListPolluantsEau} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListPolluantsEau 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielPorts } \emph{ Pagination \&quot;referentiel - ports\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - ports\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, MCA_CODE, MCA_NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } MCA_CODE character
#' \item \emph{ @param } MCA_NAME character
#' \item \emph{ @returnType } \link{PaginateListPorts} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListPorts 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielStationsAir } \emph{ Pagination \&quot;referentiel - stationsAir\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - stationsAir\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } CODE_ZAS character
#' \item \emph{ @param } NAME_ZAS character
#' \item \emph{ @param } COMMUNE character
#' \item \emph{ @param } AASQA character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } ALTITUDE character
#' \item \emph{ @param } VALIDITY_START character
#' \item \emph{ @param } VALIDITY_END character
#' \item \emph{ @param } SECTOR_TYPE character
#' \item \emph{ @param } MILLESIME character
#' \item \emph{ @param } impact.pm10 character
#' \item \emph{ @param } impact.no2 character
#' \item \emph{ @param } impact.o3 character
#' \item \emph{ @param } impact.so2 character
#' \item \emph{ @param } impact.pm25 character
#' \item \emph{ @param } IMPACT_CO character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @returnType } \link{PaginateListStationsAir} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListStationsAir 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielStationsEsu } \emph{ Pagination \&quot;referentiel - stationsEsu\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - stationsEsu\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] > 
#' \item \emph{ @param } columns Enum < [CODE, LONGITUDE, LATITUDE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } LONGITUDE character
#' \item \emph{ @param } LATITUDE character
#' \item \emph{ @param } LOCATION character
#' \item \emph{ @returnType } \link{PaginateListStationsEsu} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListStationsEsu 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateReferentielTags } \emph{ Pagination \&quot;referentiel - tags\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;referentiel - tags\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] > 
#' \item \emph{ @param } columns Enum < [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] > 
#' \item \emph{ @param } VALUE character
#' \item \emph{ @param } DISPLAY character
#' \item \emph{ @param } TOPICS character
#' \item \emph{ @param } EUROVOC character
#' \item \emph{ @param } ECOPLANET character
#' \item \emph{ @returnType } \link{PaginateListTags} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListTags 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ExportCsvReferentielCog  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Export csv \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielCog(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  ExportCsvReferentielGeozones  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"referentiel - geozones\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielGeozones(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
#'
#'
#' ####################  ExportCsvReferentielPolluantsEau  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"referentiel - polluantsEau\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielPolluantsEau(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
#'
#'
#' ####################  ExportCsvReferentielPorts  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"referentiel - ports\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielPorts(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
#'
#'
#' ####################  ExportCsvReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export csv \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielStationsAir(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportCsvReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export csv \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielStationsEsu(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportCsvReferentielTags  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
#' var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
#' var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
#' var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
#' var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
#' var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"referentiel - tags\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportCsvReferentielTags(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
#'
#'
#' ####################  ExportGeojsonReferentielCog  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Export geojson \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportGeojsonReferentielCog(var.geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  ExportGeojsonReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export geojson \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportGeojsonReferentielStationsAir(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportGeojsonReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export geojson \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportGeojsonReferentielStationsEsu(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportJsonReferentielCog  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Export json \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielCog(order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  ExportJsonReferentielGeozones  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"referentiel - geozones\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielGeozones(order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
#'
#'
#' ####################  ExportJsonReferentielPolluantsEau  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"referentiel - polluantsEau\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielPolluantsEau(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
#'
#'
#' ####################  ExportJsonReferentielPorts  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"referentiel - ports\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielPorts(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
#'
#'
#' ####################  ExportJsonReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export json \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielStationsAir(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportJsonReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export json \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielStationsEsu(order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportJsonReferentielTags  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
#' var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
#' var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
#' var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
#' var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
#' var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"referentiel - tags\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportJsonReferentielTags(order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
#'
#'
#' ####################  ExportShapefileReferentielCog  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Export shapefile \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportShapefileReferentielCog(var.geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  ExportShapefileReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export shapefile \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportShapefileReferentielStationsAir(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportShapefileReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export shapefile \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportShapefileReferentielStationsEsu(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportXlsxReferentielCog  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Export xlsx \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielCog(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  ExportXlsxReferentielGeozones  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"referentiel - geozones\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielGeozones(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
#'
#'
#' ####################  ExportXlsxReferentielPolluantsEau  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"referentiel - polluantsEau\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielPolluantsEau(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
#'
#'
#' ####################  ExportXlsxReferentielPorts  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"referentiel - ports\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielPorts(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
#'
#'
#' ####################  ExportXlsxReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export xlsx \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielStationsAir(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportXlsxReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Export xlsx \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielStationsEsu(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  ExportXlsxReferentielTags  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
#' var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
#' var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
#' var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
#' var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
#' var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"referentiel - tags\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$ExportXlsxReferentielTags(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
#'
#'
#' ####################  GetIdReferentielCog  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - cog\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielCog(var.id)
#'
#'
#' ####################  GetIdReferentielGeozones  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - geozones\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - geozones\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielGeozones(var.id)
#'
#'
#' ####################  GetIdReferentielPolluantsEau  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - polluantsEau\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - polluantsEau\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielPolluantsEau(var.id)
#'
#'
#' ####################  GetIdReferentielPorts  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - ports\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - ports\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielPorts(var.id)
#'
#'
#' ####################  GetIdReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - stationsAir\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielStationsAir(var.id)
#'
#'
#' ####################  GetIdReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - stationsEsu\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielStationsEsu(var.id)
#'
#'
#' ####################  GetIdReferentielTags  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - tags\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"referentiel - tags\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$GetIdReferentielTags(var.id)
#'
#'
#' ####################  PaginateReferentielCog  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
#' var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#' var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within
#'
#' #Pagination \"referentiel - cog\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielCog(var.page, var.page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
#'
#'
#' ####################  PaginateReferentielGeozones  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
#' var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"referentiel - geozones\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielGeozones(var.page, var.page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
#'
#'
#' ####################  PaginateReferentielPolluantsEau  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"referentiel - polluantsEau\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielPolluantsEau(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
#'
#'
#' ####################  PaginateReferentielPorts  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"referentiel - ports\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielPorts(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
#'
#'
#' ####################  PaginateReferentielStationsAir  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
#' var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
#' var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
#' var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Pagination \"referentiel - stationsAir\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielStationsAir(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
#'
#'
#' ####################  PaginateReferentielStationsEsu  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
#' var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
#'
#' #Pagination \"referentiel - stationsEsu\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielStationsEsu(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
#'
#'
#' ####################  PaginateReferentielTags  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
#' var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
#' var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
#' var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
#' var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
#' var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"referentiel - tags\"
#' api.instance <- ReferentielsApi$new()
#'
#' result <- api.instance$PaginateReferentielTags(var.page, var.page.size, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ReferentielsApi <- R6::R6Class(
  'ReferentielsApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ExportCsvReferentielCog = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$ExportCsvReferentielCogWithHttpInfo(with.column.name, with.column.description, order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielCogWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielGeozones = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportCsvReferentielGeozonesWithHttpInfo(with.column.name, with.column.description, order.by, columns, ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielGeozonesWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE'] <- CODE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/referentiels/geozones/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielPolluantsEau = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      apiResponse <- self$ExportCsvReferentielPolluantsEauWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, UNIT, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielPolluantsEauWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      body <- NULL
      urlPath <- "/v1/referentiels/polluantsEau/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielPorts = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      apiResponse <- self$ExportCsvReferentielPortsWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, MCA_CODE, MCA_NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielPortsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['MCA_CODE'] <- MCA_CODE

      queryParams['MCA_NAME'] <- MCA_NAME

      body <- NULL
      urlPath <- "/v1/referentiels/ports/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielStationsAir = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportCsvReferentielStationsAirWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielStationsAirWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielStationsEsu = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportCsvReferentielStationsEsuWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielStationsEsuWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvReferentielTags = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      apiResponse <- self$ExportCsvReferentielTagsWithHttpInfo(with.column.name, with.column.description, order.by, columns, VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvReferentielTagsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['VALUE'] <- VALUE

      queryParams['DISPLAY'] <- DISPLAY

      queryParams['TOPICS'] <- TOPICS

      queryParams['EUROVOC'] <- EUROVOC

      queryParams['ECOPLANET'] <- ECOPLANET

      body <- NULL
      urlPath <- "/v1/referentiels/tags/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportGeojsonReferentielCog = function(geo.field, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$ExportGeojsonReferentielCogWithHttpInfo(geo.field, order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportGeojsonReferentielCogWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog/spatial/geojson"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportGeojsonReferentielStationsAir = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportGeojsonReferentielStationsAirWithHttpInfo(geo.field, order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportGeojsonReferentielStationsAirWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/spatial/geojson"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportGeojsonReferentielStationsEsu = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportGeojsonReferentielStationsEsuWithHttpInfo(geo.field, order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportGeojsonReferentielStationsEsuWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/spatial/geojson"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielCog = function(order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$ExportJsonReferentielCogWithHttpInfo(order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielCogWithHttpInfo = function(order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielGeozones = function(order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportJsonReferentielGeozonesWithHttpInfo(order.by, columns, ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielGeozonesWithHttpInfo = function(order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE'] <- CODE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/referentiels/geozones/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielPolluantsEau = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      apiResponse <- self$ExportJsonReferentielPolluantsEauWithHttpInfo(order.by, columns, CODE, NAME, UNIT, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielPolluantsEauWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      body <- NULL
      urlPath <- "/v1/referentiels/polluantsEau/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielPorts = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      apiResponse <- self$ExportJsonReferentielPortsWithHttpInfo(order.by, columns, CODE, NAME, MCA_CODE, MCA_NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielPortsWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['MCA_CODE'] <- MCA_CODE

      queryParams['MCA_NAME'] <- MCA_NAME

      body <- NULL
      urlPath <- "/v1/referentiels/ports/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielStationsAir = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportJsonReferentielStationsAirWithHttpInfo(order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielStationsAirWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielStationsEsu = function(order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportJsonReferentielStationsEsuWithHttpInfo(order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielStationsEsuWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonReferentielTags = function(order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      apiResponse <- self$ExportJsonReferentielTagsWithHttpInfo(order.by, columns, VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonReferentielTagsWithHttpInfo = function(order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['VALUE'] <- VALUE

      queryParams['DISPLAY'] <- DISPLAY

      queryParams['TOPICS'] <- TOPICS

      queryParams['EUROVOC'] <- EUROVOC

      queryParams['ECOPLANET'] <- ECOPLANET

      body <- NULL
      urlPath <- "/v1/referentiels/tags/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportShapefileReferentielCog = function(geo.field, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$ExportShapefileReferentielCogWithHttpInfo(geo.field, order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportShapefileReferentielCogWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog/spatial/shapefile"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportShapefileReferentielStationsAir = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportShapefileReferentielStationsAirWithHttpInfo(geo.field, order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportShapefileReferentielStationsAirWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/spatial/shapefile"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportShapefileReferentielStationsEsu = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportShapefileReferentielStationsEsuWithHttpInfo(geo.field, order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportShapefileReferentielStationsEsuWithHttpInfo = function(geo.field, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/spatial/shapefile"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielCog = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielCogWithHttpInfo(with.column.name, with.column.description, order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielCogWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielGeozones = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielGeozonesWithHttpInfo(with.column.name, with.column.description, order.by, columns, ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielGeozonesWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE'] <- CODE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/referentiels/geozones/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielPolluantsEau = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielPolluantsEauWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, UNIT, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielPolluantsEauWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      body <- NULL
      urlPath <- "/v1/referentiels/polluantsEau/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielPorts = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielPortsWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, MCA_CODE, MCA_NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielPortsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['MCA_CODE'] <- MCA_CODE

      queryParams['MCA_NAME'] <- MCA_NAME

      body <- NULL
      urlPath <- "/v1/referentiels/ports/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielStationsAir = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielStationsAirWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielStationsAirWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielStationsEsu = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielStationsEsuWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielStationsEsuWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxReferentielTags = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      apiResponse <- self$ExportXlsxReferentielTagsWithHttpInfo(with.column.name, with.column.description, order.by, columns, VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxReferentielTagsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['VALUE'] <- VALUE

      queryParams['DISPLAY'] <- DISPLAY

      queryParams['TOPICS'] <- TOPICS

      queryParams['EUROVOC'] <- EUROVOC

      queryParams['ECOPLANET'] <- ECOPLANET

      body <- NULL
      urlPath <- "/v1/referentiels/tags/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielCog = function(id, ...){
      apiResponse <- self$GetIdReferentielCogWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielCogWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/cog/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemCog", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielGeozones = function(id, ...){
      apiResponse <- self$GetIdReferentielGeozonesWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielGeozonesWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/geozones/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemGeozones", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielPolluantsEau = function(id, ...){
      apiResponse <- self$GetIdReferentielPolluantsEauWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielPolluantsEauWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/polluantsEau/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemPolluantsEau", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielPorts = function(id, ...){
      apiResponse <- self$GetIdReferentielPortsWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielPortsWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/ports/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemPorts", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielStationsAir = function(id, ...){
      apiResponse <- self$GetIdReferentielStationsAirWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielStationsAirWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemStationsAir", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielStationsEsu = function(id, ...){
      apiResponse <- self$GetIdReferentielStationsEsuWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielStationsEsuWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemStationsEsu", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdReferentielTags = function(id, ...){
      apiResponse <- self$GetIdReferentielTagsWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdReferentielTagsWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/referentiels/tags/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemTags", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielCog = function(page, page.size, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      apiResponse <- self$PaginateReferentielCogWithHttpInfo(page, page.size, order.by, columns, ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, LOCATION, SHAPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielCogWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, ID=NULL, MILLESIME=NULL, TYPE=NULL, LEVEL=NULL, CODE_MILLESIME=NULL, CODE_CURRENT=NULL, OFFICIAL_NAME=NULL, UPPER_NAME=NULL, LOWER_NAME=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, SHAPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['TYPE'] <- TYPE

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE_MILLESIME'] <- CODE_MILLESIME

      queryParams['CODE_CURRENT'] <- CODE_CURRENT

      queryParams['OFFICIAL_NAME'] <- OFFICIAL_NAME

      queryParams['UPPER_NAME'] <- UPPER_NAME

      queryParams['LOWER_NAME'] <- LOWER_NAME

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      queryParams['SHAPE'] <- SHAPE

      body <- NULL
      urlPath <- "/v1/referentiels/cog"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListCog", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielGeozones = function(page, page.size, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      apiResponse <- self$PaginateReferentielGeozonesWithHttpInfo(page, page.size, order.by, columns, ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielGeozonesWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, ID=NULL, LEVEL=NULL, CODE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['ID'] <- ID

      queryParams['LEVEL'] <- LEVEL

      queryParams['CODE'] <- CODE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/referentiels/geozones"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListGeozones", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielPolluantsEau = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      apiResponse <- self$PaginateReferentielPolluantsEauWithHttpInfo(page, page.size, order.by, columns, CODE, NAME, UNIT, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielPolluantsEauWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      body <- NULL
      urlPath <- "/v1/referentiels/polluantsEau"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListPolluantsEau", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielPorts = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      apiResponse <- self$PaginateReferentielPortsWithHttpInfo(page, page.size, order.by, columns, CODE, NAME, MCA_CODE, MCA_NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielPortsWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, MCA_CODE=NULL, MCA_NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['MCA_CODE'] <- MCA_CODE

      queryParams['MCA_NAME'] <- MCA_NAME

      body <- NULL
      urlPath <- "/v1/referentiels/ports"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListPorts", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielStationsAir = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      apiResponse <- self$PaginateReferentielStationsAirWithHttpInfo(page, page.size, order.by, columns, CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, impact.pm10, impact.no2, impact.o3, impact.so2, impact.pm25, IMPACT_CO, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielStationsAirWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, CODE_ZAS=NULL, NAME_ZAS=NULL, COMMUNE=NULL, AASQA=NULL, LONGITUDE=NULL, LATITUDE=NULL, ALTITUDE=NULL, VALIDITY_START=NULL, VALIDITY_END=NULL, SECTOR_TYPE=NULL, MILLESIME=NULL, impact.pm10=NULL, impact.no2=NULL, impact.o3=NULL, impact.so2=NULL, impact.pm25=NULL, IMPACT_CO=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['CODE_ZAS'] <- CODE_ZAS

      queryParams['NAME_ZAS'] <- NAME_ZAS

      queryParams['COMMUNE'] <- COMMUNE

      queryParams['AASQA'] <- AASQA

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['ALTITUDE'] <- ALTITUDE

      queryParams['VALIDITY_START'] <- VALIDITY_START

      queryParams['VALIDITY_END'] <- VALIDITY_END

      queryParams['SECTOR_TYPE'] <- SECTOR_TYPE

      queryParams['MILLESIME'] <- MILLESIME

      queryParams['IMPACT_PM10'] <- impact.pm10

      queryParams['IMPACT_NO2'] <- impact.no2

      queryParams['IMPACT_O3'] <- impact.o3

      queryParams['IMPACT_SO2'] <- impact.so2

      queryParams['IMPACT_PM25'] <- impact.pm25

      queryParams['IMPACT_CO'] <- IMPACT_CO

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsAir"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListStationsAir", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielStationsEsu = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      apiResponse <- self$PaginateReferentielStationsEsuWithHttpInfo(page, page.size, order.by, columns, CODE, LONGITUDE, LATITUDE, LOCATION, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielStationsEsuWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, LONGITUDE=NULL, LATITUDE=NULL, LOCATION=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['LONGITUDE'] <- LONGITUDE

      queryParams['LATITUDE'] <- LATITUDE

      queryParams['LOCATION'] <- LOCATION

      body <- NULL
      urlPath <- "/v1/referentiels/stationsEsu"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListStationsEsu", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateReferentielTags = function(page, page.size, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      apiResponse <- self$PaginateReferentielTagsWithHttpInfo(page, page.size, order.by, columns, VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateReferentielTagsWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, VALUE=NULL, DISPLAY=NULL, TOPICS=NULL, EUROVOC=NULL, ECOPLANET=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['VALUE'] <- VALUE

      queryParams['DISPLAY'] <- DISPLAY

      queryParams['TOPICS'] <- TOPICS

      queryParams['EUROVOC'] <- EUROVOC

      queryParams['ECOPLANET'] <- ECOPLANET

      body <- NULL
      urlPath <- "/v1/referentiels/tags"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListTags", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
