# DiDo - API diffusion
#
# API de diffusion des données de DiDo sur Internet
#
# The version of the OpenAPI document: 1.0.0
# Contact: support-dido@developpement-durable.gouv.fr
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Datafiles operations
#' @description didoscalie.Datafiles
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ExportCsvMillesimeDatafile } \emph{ Export csv d&#39;un milléime de fichier de données }
#' Permet d&#39;obtenir un export csv d&#39;un millésime de fichier de données.              Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } with.column.unit character
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportGeojsonMillesimeDatafile } \emph{ Export geojson d&#39;un milléime de fichier de données }
#' Permet d&#39;obtenir un export geojson d&#39;un millésime de fichier de données.              Cette route n&#39;existe que pour les fichiers de données qui utilisent un référentiel géographique.             Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } geo.field character
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#'
#'
#' \item status code : 200 | Réponse avec un export geojson d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonMillesimeDatafile } \emph{ Export json d&#39;un milléime de fichier de données }
#' Permet d&#39;obtenir un export json d&#39;un millésime de fichier de données.              Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportShapefileMillesimeDatafile } \emph{ Export shapefile d&#39;un milléime de fichier de données }
#' Permet d&#39;obtenir un export shapefile d&#39;un millésime de fichier de données.              Cette route n&#39;existe que pour les fichiers de données qui utilisent un référentiel géographique.             Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } geo.field character
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#'
#'
#' \item status code : 200 | Réponse avec un export shapefile d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxMillesimeDatafile } \emph{ Export xlsx d&#39;un milléime de fichier de données }
#' Permet d&#39;obtenir un export xlsx d&#39;un millésime de fichier de données.              Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } with.column.unit character
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetMillesimeDatafile } \emph{ Détail du millésime d&#39;un fichier de données (identifiée par son rid et son numéro de millésime -le dernier si le millésime n&#39;est pas saisi). }
#' Permet d&#39;obtenir le détail d&#39;un fichier de données qui est identifié par son rid et son numéro de millésime. Si le numéro de millésime n&#39;est pas précisé, le dernier millésime du fichier de données est renvoyé.
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } millesime character
#' \item \emph{ @returnType } \link{MillesimeDatafile} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un millésime de fichier de données
#'
#' \item return type : MillesimeDatafile 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 206 | Réponse avec une le détail d&#39;un millésime de fichier de données qui est encore sous embargo (la date de publication est dans le future)
#'
#' \item return type : MillesimeDatafileNoData 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateDatafiles } \emph{ Pagination des fichiers de données }
#' Permet d&#39;obtenir une liste paginée des fichiers de données présents dans DiDo. Il est possible de spécifier le nombre de jeux de données à retourner, le numéro de la page à retourner et ajouter des critères de tri et de filtrage.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [all, 10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [title, -title, last_modified, -last_modified] > 
#' \item \emph{ @param } text character
#' \item \emph{ @returnType } \link{PaginateListDatafiles} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée de fichier de données
#'
#' \item return type : PaginateListDatafiles 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateMillesimeDatafile } \emph{ Pagination des données d&#39;un millésime d&#39;un fichier de données }
#' Permet d&#39;obtenir une liste paginée des données d&#39;un millésime de fichier de données.              Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.              Il existe une apidoc dédiée à chaque millésime où les paramètres de tri, de sélection de colonnes et de tri spécifique au millésime sont détaillés:              https://data.statistiques.developpement-durable.gouv.fr/dido/api/v1/datafiles/{rid}/millesime&#x3D;{millesime}/apidoc.html
#'
#' \itemize{
#' \item \emph{ @param } rid character
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } millesime character
#' \item \emph{ @param } order.by list( character )
#' \item \emph{ @param } columns list( character )
#' \item \emph{ @returnType } \link{PaginateListRows} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListRows 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ExportCsvMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.with.column.unit <- 'with.column.unit_example' # character | faut-il ajouter l'unité des colonnes en entête du fichier csv ?
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Export csv d'un milléime de fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$ExportCsvMillesimeDatafile(var.rid, var.with.column.name, var.with.column.description, var.with.column.unit, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' ####################  ExportGeojsonMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.geo.field <- 'COMMUNE' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Export geojson d'un milléime de fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$ExportGeojsonMillesimeDatafile(var.rid, var.geo.field, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' ####################  ExportJsonMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Export json d'un milléime de fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$ExportJsonMillesimeDatafile(var.rid, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' ####################  ExportShapefileMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.geo.field <- 'COMMUNE' # character | Champ pivot pour la génération du geojson ou du shapefile
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Export shapefile d'un milléime de fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$ExportShapefileMillesimeDatafile(var.rid, var.geo.field, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' ####################  ExportXlsxMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.with.column.unit <- 'with.column.unit_example' # character | faut-il ajouter l'unité des colonnes en entête du fichier csv ?
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Export xlsx d'un milléime de fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$ExportXlsxMillesimeDatafile(var.rid, var.with.column.name, var.with.column.description, var.with.column.unit, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' ####################  GetMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#'
#' #Détail du millésime d'un fichier de données (identifiée par son rid et son numéro de millésime -le dernier si le millésime n'est pas saisi).
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$GetMillesimeDatafile(var.rid, millesime=var.millesime)
#'
#'
#' ####################  PaginateDatafiles  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri des fichiers de données
#' var.text <- 'text_example' # character | Texte à rechercher dans le titre ou la description du fichier de données
#'
#' #Pagination des fichiers de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$PaginateDatafiles(var.page, var.page.size, order.by=var.order.by, text=var.text)
#'
#'
#' ####################  PaginateMillesimeDatafile  ####################
#'
#' library(didoscalie)
#' var.rid <- 'rid_example' # character | Identifiant du fichier de données.
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.millesime <- 'millesime_example' # character | Millésime du fichier de données (le dernier millésime sera retournée si valeur omise) - format YYYY-MM
#' var.order.by <- ['-colonne1,colonne2'] # array[character] | Options de tri.       Les différents champs doivent être séparés par une virgule. Si il s'agit d'un tri descendant, il faut rajouter - devant.       Par exemple pour un fichier ayant les entêtes colonne1 et colonne2, une valeur pourrait être \"-colonne1,colonne2' pour trier d'abord par entete1 de manière décroissante puis par entete2 de manière croissante
#' var.columns <- ['colonne1,colonne2'] # array[character] | Les colonnes à récupérer.       Les colonnes à récupérer séparées par une virgule. Par exemple \"colonne,colonne2\" pour récupérer uniquement les colonnes entete1 et entete2.
#'
#' #Pagination des données d'un millésime d'un fichier de données
#' api.instance <- DatafilesApi$new()
#'
#' result <- api.instance$PaginateMillesimeDatafile(var.rid, var.page, var.page.size, millesime=var.millesime, order.by=var.order.by, columns=var.columns)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
DatafilesApi <- R6::R6Class(
  'DatafilesApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ExportCsvMillesimeDatafile = function(rid, with.column.name, with.column.description, with.column.unit, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$ExportCsvMillesimeDatafileWithHttpInfo(rid, with.column.name, with.column.description, with.column.unit, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvMillesimeDatafileWithHttpInfo = function(rid, with.column.name, with.column.description, with.column.unit, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      if (missing(`with.column.unit`)) {
        stop("Missing required parameter `with.column.unit`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['withColumnUnit'] <- with.column.unit

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/csv"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportGeojsonMillesimeDatafile = function(rid, geo.field, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$ExportGeojsonMillesimeDatafileWithHttpInfo(rid, geo.field, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportGeojsonMillesimeDatafileWithHttpInfo = function(rid, geo.field, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/spatial/geojson"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonMillesimeDatafile = function(rid, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$ExportJsonMillesimeDatafileWithHttpInfo(rid, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonMillesimeDatafileWithHttpInfo = function(rid, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/json"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportShapefileMillesimeDatafile = function(rid, geo.field, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$ExportShapefileMillesimeDatafileWithHttpInfo(rid, geo.field, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportShapefileMillesimeDatafileWithHttpInfo = function(rid, geo.field, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      if (missing(`geo.field`)) {
        stop("Missing required parameter `geo.field`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['geoField'] <- geo.field

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/spatial/shapefile"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxMillesimeDatafile = function(rid, with.column.name, with.column.description, with.column.unit, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$ExportXlsxMillesimeDatafileWithHttpInfo(rid, with.column.name, with.column.description, with.column.unit, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxMillesimeDatafileWithHttpInfo = function(rid, with.column.name, with.column.description, with.column.unit, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      if (missing(`with.column.unit`)) {
        stop("Missing required parameter `with.column.unit`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['withColumnUnit'] <- with.column.unit

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/xlsx"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetMillesimeDatafile = function(rid, millesime=NULL, ...){
      apiResponse <- self$GetMillesimeDatafileWithHttpInfo(rid, millesime, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetMillesimeDatafileWithHttpInfo = function(rid, millesime=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      queryParams['millesime'] <- millesime

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "MillesimeDatafile", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateDatafiles = function(page, page.size, order.by=NULL, text=NULL, ...){
      apiResponse <- self$PaginateDatafilesWithHttpInfo(page, page.size, order.by, text, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateDatafilesWithHttpInfo = function(page, page.size, order.by=NULL, text=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['text'] <- text

      body <- NULL
      urlPath <- "/v1/datafiles"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListDatafiles", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateMillesimeDatafile = function(rid, page, page.size, millesime=NULL, order.by=NULL, columns=NULL, ...){
      apiResponse <- self$PaginateMillesimeDatafileWithHttpInfo(rid, page, page.size, millesime, order.by, columns, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateMillesimeDatafileWithHttpInfo = function(rid, page, page.size, millesime=NULL, order.by=NULL, columns=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`rid`)) {
        stop("Missing required parameter `rid`.")
      }

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['millesime'] <- millesime

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      body <- NULL
      urlPath <- "/v1/datafiles/{rid}/rows"
      if (!missing(`rid`)) {
        urlPath <- gsub(paste0("\\{", "rid", "\\}"), URLencode(as.character(`rid`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListRows", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
