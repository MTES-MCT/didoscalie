# DiDo - API diffusion
#
# API de diffusion des données de DiDo sur Internet
#
# The version of the OpenAPI document: 1.0.0
# Contact: support-dido@developpement-durable.gouv.fr
# Generated by: https://openapi-generator.tech

#' @docType class
#' @title Nomenclatures operations
#' @description didoscalie.Nomenclatures
#' @format An \code{R6Class} generator object
#' @field apiClient Handles the client-server communication.
#'
#' @section Methods:
#' \describe{
#' \strong{ ExportCsvNomenclatureBilanEnergie } \emph{ Export csv \&quot;nomenclature - bilanEnergie\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, -CODE, -NAME, -UNIT, -LEVEL, -DATA_TYPE, -FLOW_TYPE] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } DATA_TYPE character
#' \item \emph{ @param } FLOW_TYPE character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvNomenclatureCslFilieres } \emph{ Export csv \&quot;nomenclature - cslFilieres\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, -CODE, -NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportCsvNomenclatureCslOperations } \emph{ Export csv \&quot;nomenclature - cslOperations\&quot; }
#' Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4, -CODE_1, -NAME_1, -CODE_2, -NAME_2, -CODE_3, -NAME_3, -CODE_4, -NAME_4] > 
#' \item \emph{ @param } columns Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4] > 
#' \item \emph{ @param } code.1 character
#' \item \emph{ @param } name.1 character
#' \item \emph{ @param } code.2 character
#' \item \emph{ @param } name.2 character
#' \item \emph{ @param } code.3 character
#' \item \emph{ @param } name.3 character
#' \item \emph{ @param } code.4 character
#' \item \emph{ @param } name.4 character
#'
#'
#' \item status code : 200 | Réponse avec un export csv d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonNomenclatureBilanEnergie } \emph{ Export json \&quot;nomenclature - bilanEnergie\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, -CODE, -NAME, -UNIT, -LEVEL, -DATA_TYPE, -FLOW_TYPE] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } DATA_TYPE character
#' \item \emph{ @param } FLOW_TYPE character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonNomenclatureCslFilieres } \emph{ Export json \&quot;nomenclature - cslFilieres\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE, NAME, -CODE, -NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportJsonNomenclatureCslOperations } \emph{ Export json \&quot;nomenclature - cslOperations\&quot; }
#' Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } order.by Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4, -CODE_1, -NAME_1, -CODE_2, -NAME_2, -CODE_3, -NAME_3, -CODE_4, -NAME_4] > 
#' \item \emph{ @param } columns Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4] > 
#' \item \emph{ @param } code.1 character
#' \item \emph{ @param } name.1 character
#' \item \emph{ @param } code.2 character
#' \item \emph{ @param } name.2 character
#' \item \emph{ @param } code.3 character
#' \item \emph{ @param } name.3 character
#' \item \emph{ @param } code.4 character
#' \item \emph{ @param } name.4 character
#'
#'
#' \item status code : 200 | Réponse avec un export json d&#39;éléments
#'
#' \item return type : character 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxNomenclatureBilanEnergie } \emph{ Export xlsx \&quot;nomenclature - bilanEnergie\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, -CODE, -NAME, -UNIT, -LEVEL, -DATA_TYPE, -FLOW_TYPE] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } DATA_TYPE character
#' \item \emph{ @param } FLOW_TYPE character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxNomenclatureCslFilieres } \emph{ Export xlsx \&quot;nomenclature - cslFilieres\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE, NAME, -CODE, -NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ ExportXlsxNomenclatureCslOperations } \emph{ Export xlsx \&quot;nomenclature - cslOperations\&quot; }
#' Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } with.column.name character
#' \item \emph{ @param } with.column.description character
#' \item \emph{ @param } order.by Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4, -CODE_1, -NAME_1, -CODE_2, -NAME_2, -CODE_3, -NAME_3, -CODE_4, -NAME_4] > 
#' \item \emph{ @param } columns Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4] > 
#' \item \emph{ @param } code.1 character
#' \item \emph{ @param } name.1 character
#' \item \emph{ @param } code.2 character
#' \item \emph{ @param } name.2 character
#' \item \emph{ @param } code.3 character
#' \item \emph{ @param } name.3 character
#' \item \emph{ @param } code.4 character
#' \item \emph{ @param } name.4 character
#'
#'
#' \item status code : 200 | Réponse avec un export xlsx d&#39;éléments
#'
#' \item return type : data.frame 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdNomenclatureBilanEnergie } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - bilanEnergie\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - bilanEnergie\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemBilanEnergie} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemBilanEnergie 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdNomenclatureCslFilieres } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - cslFilieres\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - cslFilieres\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemCslFilieres} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemCslFilieres 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ GetIdNomenclatureCslOperations } \emph{ Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - cslOperations\&quot; }
#' Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - cslOperations\&quot; dont on connaît l&#39;id.
#'
#' \itemize{
#' \item \emph{ @param } id character
#' \item \emph{ @returnType } \link{ItemCslOperations} \cr
#'
#'
#' \item status code : 200 | Réponse avec une le détail d&#39;un élément
#'
#' \item return type : ItemCslOperations 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateNomenclatureBilanEnergie } \emph{ Pagination \&quot;nomenclature - bilanEnergie\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, -CODE, -NAME, -UNIT, -LEVEL, -DATA_TYPE, -FLOW_TYPE] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @param } UNIT character
#' \item \emph{ @param } LEVEL character
#' \item \emph{ @param } DATA_TYPE character
#' \item \emph{ @param } FLOW_TYPE character
#' \item \emph{ @returnType } \link{PaginateListBilanEnergie} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListBilanEnergie 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateNomenclatureCslFilieres } \emph{ Pagination \&quot;nomenclature - cslFilieres\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE, NAME, -CODE, -NAME] > 
#' \item \emph{ @param } columns Enum < [CODE, NAME] > 
#' \item \emph{ @param } CODE character
#' \item \emph{ @param } NAME character
#' \item \emph{ @returnType } \link{PaginateListCslFilieres} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListCslFilieres 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' \strong{ PaginateNomenclatureCslOperations } \emph{ Pagination \&quot;nomenclature - cslOperations\&quot; }
#' Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
#'
#' \itemize{
#' \item \emph{ @param } page integer
#' \item \emph{ @param } page.size Enum < [10, 20, 50, 100] > 
#' \item \emph{ @param } order.by Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4, -CODE_1, -NAME_1, -CODE_2, -NAME_2, -CODE_3, -NAME_3, -CODE_4, -NAME_4] > 
#' \item \emph{ @param } columns Enum < [CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4] > 
#' \item \emph{ @param } code.1 character
#' \item \emph{ @param } name.1 character
#' \item \emph{ @param } code.2 character
#' \item \emph{ @param } name.2 character
#' \item \emph{ @param } code.3 character
#' \item \emph{ @param } name.3 character
#' \item \emph{ @param } code.4 character
#' \item \emph{ @param } name.4 character
#' \item \emph{ @returnType } \link{PaginateListCslOperations} \cr
#'
#'
#' \item status code : 200 | Réponse avec une liste paginée d&#39;éléments
#'
#' \item return type : PaginateListCslOperations 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 400 | Réponse dans le cas d&#39;une erreur de validation
#'
#' \item return type : ValidationError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 404 | Réponse si élément non trouvé
#'
#' \item return type : NotFoundError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' \item status code : 500 | Réponse si erreur interne au serveur
#'
#' \item return type : ServerError 
#' \item response headers :
#'
#' \tabular{ll}{
#' }
#' }
#'
#' }
#'
#'
#' @examples
#' \dontrun{
#' ####################  ExportCsvNomenclatureBilanEnergie  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.DATA_TYPE <- 'DATA_TYPE_example' # character | Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.FLOW_TYPE <- 'FLOW_TYPE_example' # character | Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"nomenclature - bilanEnergie\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportCsvNomenclatureBilanEnergie(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT, LEVEL=var.LEVEL, DATA_TYPE=var.DATA_TYPE, FLOW_TYPE=var.FLOW_TYPE)
#'
#'
#' ####################  ExportCsvNomenclatureCslFilieres  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"nomenclature - cslFilieres\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportCsvNomenclatureCslFilieres(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME)
#'
#'
#' ####################  ExportCsvNomenclatureCslOperations  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4
#' var.code.1 <- 'code.1_example' # character | Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.1 <- 'name.1_example' # character | Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.2 <- 'code.2_example' # character | Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.2 <- 'name.2_example' # character | Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.3 <- 'code.3_example' # character | Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.3 <- 'name.3_example' # character | Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.4 <- 'code.4_example' # character | Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.4 <- 'name.4_example' # character | Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export csv \"nomenclature - cslOperations\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportCsvNomenclatureCslOperations(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, code.1=var.code.1, name.1=var.name.1, code.2=var.code.2, name.2=var.name.2, code.3=var.code.3, name.3=var.name.3, code.4=var.code.4, name.4=var.name.4)
#'
#'
#' ####################  ExportJsonNomenclatureBilanEnergie  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.DATA_TYPE <- 'DATA_TYPE_example' # character | Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.FLOW_TYPE <- 'FLOW_TYPE_example' # character | Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"nomenclature - bilanEnergie\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportJsonNomenclatureBilanEnergie(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT, LEVEL=var.LEVEL, DATA_TYPE=var.DATA_TYPE, FLOW_TYPE=var.FLOW_TYPE)
#'
#'
#' ####################  ExportJsonNomenclatureCslFilieres  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"nomenclature - cslFilieres\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportJsonNomenclatureCslFilieres(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME)
#'
#'
#' ####################  ExportJsonNomenclatureCslOperations  ####################
#'
#' library(didoscalie)
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4
#' var.code.1 <- 'code.1_example' # character | Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.1 <- 'name.1_example' # character | Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.2 <- 'code.2_example' # character | Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.2 <- 'name.2_example' # character | Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.3 <- 'code.3_example' # character | Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.3 <- 'name.3_example' # character | Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.4 <- 'code.4_example' # character | Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.4 <- 'name.4_example' # character | Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export json \"nomenclature - cslOperations\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportJsonNomenclatureCslOperations(order.by=var.order.by, columns=var.columns, code.1=var.code.1, name.1=var.name.1, code.2=var.code.2, name.2=var.name.2, code.3=var.code.3, name.3=var.name.3, code.4=var.code.4, name.4=var.name.4)
#'
#'
#' ####################  ExportXlsxNomenclatureBilanEnergie  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.DATA_TYPE <- 'DATA_TYPE_example' # character | Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.FLOW_TYPE <- 'FLOW_TYPE_example' # character | Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"nomenclature - bilanEnergie\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportXlsxNomenclatureBilanEnergie(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT, LEVEL=var.LEVEL, DATA_TYPE=var.DATA_TYPE, FLOW_TYPE=var.FLOW_TYPE)
#'
#'
#' ####################  ExportXlsxNomenclatureCslFilieres  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"nomenclature - cslFilieres\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportXlsxNomenclatureCslFilieres(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME)
#'
#'
#' ####################  ExportXlsxNomenclatureCslOperations  ####################
#'
#' library(didoscalie)
#' var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
#' var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4
#' var.code.1 <- 'code.1_example' # character | Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.1 <- 'name.1_example' # character | Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.2 <- 'code.2_example' # character | Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.2 <- 'name.2_example' # character | Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.3 <- 'code.3_example' # character | Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.3 <- 'name.3_example' # character | Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.4 <- 'code.4_example' # character | Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.4 <- 'name.4_example' # character | Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Export xlsx \"nomenclature - cslOperations\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$ExportXlsxNomenclatureCslOperations(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, code.1=var.code.1, name.1=var.name.1, code.2=var.code.2, name.2=var.name.2, code.3=var.code.3, name.3=var.name.3, code.4=var.code.4, name.4=var.name.4)
#'
#'
#' ####################  GetIdNomenclatureBilanEnergie  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"nomenclature - bilanEnergie\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"nomenclature - bilanEnergie\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$GetIdNomenclatureBilanEnergie(var.id)
#'
#'
#' ####################  GetIdNomenclatureCslFilieres  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"nomenclature - cslFilieres\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"nomenclature - cslFilieres\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$GetIdNomenclatureCslFilieres(var.id)
#'
#'
#' ####################  GetIdNomenclatureCslOperations  ####################
#'
#' library(didoscalie)
#' var.id <- 'id_example' # character | identifiant de l'élement dans \"nomenclature - cslOperations\"
#'
#' #Détail de l'élément avec l'identifiant :id de \"nomenclature - cslOperations\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$GetIdNomenclatureCslOperations(var.id)
#'
#'
#' ####################  PaginateNomenclatureBilanEnergie  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#' var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin
#' var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
#' var.DATA_TYPE <- 'DATA_TYPE_example' # character | Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#' var.FLOW_TYPE <- 'FLOW_TYPE_example' # character | Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"nomenclature - bilanEnergie\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$PaginateNomenclatureBilanEnergie(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT, LEVEL=var.LEVEL, DATA_TYPE=var.DATA_TYPE, FLOW_TYPE=var.FLOW_TYPE)
#'
#'
#' ####################  PaginateNomenclatureCslFilieres  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME
#' var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
#' var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"nomenclature - cslFilieres\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$PaginateNomenclatureCslFilieres(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME)
#'
#'
#' ####################  PaginateNomenclatureCslOperations  ####################
#'
#' library(didoscalie)
#' var.page <- 56 # integer | Numéro de la page à afficher
#' var.page.size <- 'page.size_example' # character | Nombre de lignes par page
#' var.order.by <- ['order.by_example'] # array[character] | Options de tri
#' var.columns <- ['columns_example'] # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4
#' var.code.1 <- 'code.1_example' # character | Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.1 <- 'name.1_example' # character | Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.2 <- 'code.2_example' # character | Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.2 <- 'name.2_example' # character | Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.3 <- 'code.3_example' # character | Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.3 <- 'name.3_example' # character | Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin
#' var.code.4 <- 'code.4_example' # character | Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin
#' var.name.4 <- 'name.4_example' # character | Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin
#'
#' #Pagination \"nomenclature - cslOperations\"
#' api.instance <- NomenclaturesApi$new()
#'
#' result <- api.instance$PaginateNomenclatureCslOperations(var.page, var.page.size, order.by=var.order.by, columns=var.columns, code.1=var.code.1, name.1=var.name.1, code.2=var.code.2, name.2=var.name.2, code.3=var.code.3, name.3=var.name.3, code.4=var.code.4, name.4=var.name.4)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
NomenclaturesApi <- R6::R6Class(
  'NomenclaturesApi',
  public = list(
    apiClient = NULL,
    initialize = function(apiClient){
      if (!missing(apiClient)) {
        self$apiClient <- apiClient
      }
      else {
        self$apiClient <- ApiClient$new()
      }
    },
    ExportCsvNomenclatureBilanEnergie = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      apiResponse <- self$ExportCsvNomenclatureBilanEnergieWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvNomenclatureBilanEnergieWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      queryParams['LEVEL'] <- LEVEL

      queryParams['DATA_TYPE'] <- DATA_TYPE

      queryParams['FLOW_TYPE'] <- FLOW_TYPE

      body <- NULL
      urlPath <- "/v1/nomenclatures/bilanEnergie/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvNomenclatureCslFilieres = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportCsvNomenclatureCslFilieresWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvNomenclatureCslFilieresWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslFilieres/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportCsvNomenclatureCslOperations = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      apiResponse <- self$ExportCsvNomenclatureCslOperationsWithHttpInfo(with.column.name, with.column.description, order.by, columns, code.1, name.1, code.2, name.2, code.3, name.3, code.4, name.4, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportCsvNomenclatureCslOperationsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE_1'] <- code.1

      queryParams['NAME_1'] <- name.1

      queryParams['CODE_2'] <- code.2

      queryParams['NAME_2'] <- name.2

      queryParams['CODE_3'] <- code.3

      queryParams['NAME_3'] <- name.3

      queryParams['CODE_4'] <- code.4

      queryParams['NAME_4'] <- name.4

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslOperations/csv"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonNomenclatureBilanEnergie = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      apiResponse <- self$ExportJsonNomenclatureBilanEnergieWithHttpInfo(order.by, columns, CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonNomenclatureBilanEnergieWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      queryParams['LEVEL'] <- LEVEL

      queryParams['DATA_TYPE'] <- DATA_TYPE

      queryParams['FLOW_TYPE'] <- FLOW_TYPE

      body <- NULL
      urlPath <- "/v1/nomenclatures/bilanEnergie/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonNomenclatureCslFilieres = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportJsonNomenclatureCslFilieresWithHttpInfo(order.by, columns, CODE, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonNomenclatureCslFilieresWithHttpInfo = function(order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslFilieres/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportJsonNomenclatureCslOperations = function(order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      apiResponse <- self$ExportJsonNomenclatureCslOperationsWithHttpInfo(order.by, columns, code.1, name.1, code.2, name.2, code.3, name.3, code.4, name.4, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportJsonNomenclatureCslOperationsWithHttpInfo = function(order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE_1'] <- code.1

      queryParams['NAME_1'] <- name.1

      queryParams['CODE_2'] <- code.2

      queryParams['NAME_2'] <- name.2

      queryParams['CODE_3'] <- code.3

      queryParams['NAME_3'] <- name.3

      queryParams['CODE_4'] <- code.4

      queryParams['NAME_4'] <- name.4

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslOperations/json"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "character", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxNomenclatureBilanEnergie = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      apiResponse <- self$ExportXlsxNomenclatureBilanEnergieWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxNomenclatureBilanEnergieWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      queryParams['LEVEL'] <- LEVEL

      queryParams['DATA_TYPE'] <- DATA_TYPE

      queryParams['FLOW_TYPE'] <- FLOW_TYPE

      body <- NULL
      urlPath <- "/v1/nomenclatures/bilanEnergie/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxNomenclatureCslFilieres = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      apiResponse <- self$ExportXlsxNomenclatureCslFilieresWithHttpInfo(with.column.name, with.column.description, order.by, columns, CODE, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxNomenclatureCslFilieresWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslFilieres/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    ExportXlsxNomenclatureCslOperations = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      apiResponse <- self$ExportXlsxNomenclatureCslOperationsWithHttpInfo(with.column.name, with.column.description, order.by, columns, code.1, name.1, code.2, name.2, code.3, name.3, code.4, name.4, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    ExportXlsxNomenclatureCslOperationsWithHttpInfo = function(with.column.name, with.column.description, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`with.column.name`)) {
        stop("Missing required parameter `with.column.name`.")
      }

      if (missing(`with.column.description`)) {
        stop("Missing required parameter `with.column.description`.")
      }

      queryParams['withColumnName'] <- with.column.name

      queryParams['withColumnDescription'] <- with.column.description

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE_1'] <- code.1

      queryParams['NAME_1'] <- name.1

      queryParams['CODE_2'] <- code.2

      queryParams['NAME_2'] <- name.2

      queryParams['CODE_3'] <- code.3

      queryParams['NAME_3'] <- name.3

      queryParams['CODE_4'] <- code.4

      queryParams['NAME_4'] <- name.4

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslOperations/xlsx"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "data.frame", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdNomenclatureBilanEnergie = function(id, ...){
      apiResponse <- self$GetIdNomenclatureBilanEnergieWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdNomenclatureBilanEnergieWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/nomenclatures/bilanEnergie/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemBilanEnergie", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdNomenclatureCslFilieres = function(id, ...){
      apiResponse <- self$GetIdNomenclatureCslFilieresWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdNomenclatureCslFilieresWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslFilieres/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemCslFilieres", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    GetIdNomenclatureCslOperations = function(id, ...){
      apiResponse <- self$GetIdNomenclatureCslOperationsWithHttpInfo(id, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    GetIdNomenclatureCslOperationsWithHttpInfo = function(id, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`id`)) {
        stop("Missing required parameter `id`.")
      }

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslOperations/{id}"
      if (!missing(`id`)) {
        urlPath <- gsub(paste0("\\{", "id", "\\}"), URLencode(as.character(`id`), reserved = TRUE), urlPath)
      }


      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "ItemCslOperations", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateNomenclatureBilanEnergie = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      apiResponse <- self$PaginateNomenclatureBilanEnergieWithHttpInfo(page, page.size, order.by, columns, CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateNomenclatureBilanEnergieWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, UNIT=NULL, LEVEL=NULL, DATA_TYPE=NULL, FLOW_TYPE=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      queryParams['UNIT'] <- UNIT

      queryParams['LEVEL'] <- LEVEL

      queryParams['DATA_TYPE'] <- DATA_TYPE

      queryParams['FLOW_TYPE'] <- FLOW_TYPE

      body <- NULL
      urlPath <- "/v1/nomenclatures/bilanEnergie"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListBilanEnergie", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateNomenclatureCslFilieres = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      apiResponse <- self$PaginateNomenclatureCslFilieresWithHttpInfo(page, page.size, order.by, columns, CODE, NAME, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateNomenclatureCslFilieresWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, CODE=NULL, NAME=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE'] <- CODE

      queryParams['NAME'] <- NAME

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslFilieres"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListCslFilieres", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    },
    PaginateNomenclatureCslOperations = function(page, page.size, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      apiResponse <- self$PaginateNomenclatureCslOperationsWithHttpInfo(page, page.size, order.by, columns, code.1, name.1, code.2, name.2, code.3, name.3, code.4, name.4, ...)
      resp <- apiResponse$response
      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        apiResponse$content
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        apiResponse
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        apiResponse
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        apiResponse
      }
    },

    PaginateNomenclatureCslOperationsWithHttpInfo = function(page, page.size, order.by=NULL, columns=NULL, code.1=NULL, name.1=NULL, code.2=NULL, name.2=NULL, code.3=NULL, name.3=NULL, code.4=NULL, name.4=NULL, ...){
      args <- list(...)
      queryParams <- list()
      headerParams <- c()

      if (missing(`page`)) {
        stop("Missing required parameter `page`.")
      }

      if (missing(`page.size`)) {
        stop("Missing required parameter `page.size`.")
      }

      queryParams['page'] <- page

      queryParams['pageSize'] <- page.size

      queryParams['orderBy'] <- order.by

      queryParams['columns'] <- columns

      queryParams['CODE_1'] <- code.1

      queryParams['NAME_1'] <- name.1

      queryParams['CODE_2'] <- code.2

      queryParams['NAME_2'] <- name.2

      queryParams['CODE_3'] <- code.3

      queryParams['NAME_3'] <- name.3

      queryParams['CODE_4'] <- code.4

      queryParams['NAME_4'] <- name.4

      body <- NULL
      urlPath <- "/v1/nomenclatures/cslOperations"

      resp <- self$apiClient$CallApi(url = paste0(self$apiClient$basePath, urlPath),
                                 method = "GET",
                                 queryParams = queryParams,
                                 headerParams = headerParams,
                                 body = body,
                                 ...)

      if (httr::status_code(resp) >= 200 && httr::status_code(resp) <= 299) {
        deserializedRespObj <- tryCatch(
          self$apiClient$deserialize(resp, "PaginateListCslOperations", loadNamespace("didoscalie")),
          error = function(e){
             stop("Failed to deserialize response")
          }
        )
        ApiResponse$new(deserializedRespObj, resp)
      } else if (httr::status_code(resp) >= 300 && httr::status_code(resp) <= 399) {
        ApiResponse$new(paste("Server returned " , httr::status_code(resp) , " response status code."), resp)
      } else if (httr::status_code(resp) >= 400 && httr::status_code(resp) <= 499) {
        ApiResponse$new("API client error", resp)
      } else if (httr::status_code(resp) >= 500 && httr::status_code(resp) <= 599) {
        ApiResponse$new("API server error", resp)
      }
    }
  )
)
