# ReferentielsApi

All URIs are relative to *https://data.statistiques.developpement-durable.gouv.fr/dido/api*

Method | HTTP request | Description
------------- | ------------- | -------------
[**ExportCsvReferentielCog**](ReferentielsApi.md#ExportCsvReferentielCog) | **GET** /v1/referentiels/cog/csv | Export csv \&quot;referentiel - cog\&quot;
[**ExportCsvReferentielGeozones**](ReferentielsApi.md#ExportCsvReferentielGeozones) | **GET** /v1/referentiels/geozones/csv | Export csv \&quot;referentiel - geozones\&quot;
[**ExportCsvReferentielPolluantsEau**](ReferentielsApi.md#ExportCsvReferentielPolluantsEau) | **GET** /v1/referentiels/polluantsEau/csv | Export csv \&quot;referentiel - polluantsEau\&quot;
[**ExportCsvReferentielPorts**](ReferentielsApi.md#ExportCsvReferentielPorts) | **GET** /v1/referentiels/ports/csv | Export csv \&quot;referentiel - ports\&quot;
[**ExportCsvReferentielStationsAir**](ReferentielsApi.md#ExportCsvReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/csv | Export csv \&quot;referentiel - stationsAir\&quot;
[**ExportCsvReferentielStationsEsu**](ReferentielsApi.md#ExportCsvReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/csv | Export csv \&quot;referentiel - stationsEsu\&quot;
[**ExportCsvReferentielTags**](ReferentielsApi.md#ExportCsvReferentielTags) | **GET** /v1/referentiels/tags/csv | Export csv \&quot;referentiel - tags\&quot;
[**ExportGeojsonReferentielCog**](ReferentielsApi.md#ExportGeojsonReferentielCog) | **GET** /v1/referentiels/cog/spatial/geojson | Export geojson \&quot;referentiel - cog\&quot;
[**ExportGeojsonReferentielStationsAir**](ReferentielsApi.md#ExportGeojsonReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/spatial/geojson | Export geojson \&quot;referentiel - stationsAir\&quot;
[**ExportGeojsonReferentielStationsEsu**](ReferentielsApi.md#ExportGeojsonReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/spatial/geojson | Export geojson \&quot;referentiel - stationsEsu\&quot;
[**ExportJsonReferentielCog**](ReferentielsApi.md#ExportJsonReferentielCog) | **GET** /v1/referentiels/cog/json | Export json \&quot;referentiel - cog\&quot;
[**ExportJsonReferentielGeozones**](ReferentielsApi.md#ExportJsonReferentielGeozones) | **GET** /v1/referentiels/geozones/json | Export json \&quot;referentiel - geozones\&quot;
[**ExportJsonReferentielPolluantsEau**](ReferentielsApi.md#ExportJsonReferentielPolluantsEau) | **GET** /v1/referentiels/polluantsEau/json | Export json \&quot;referentiel - polluantsEau\&quot;
[**ExportJsonReferentielPorts**](ReferentielsApi.md#ExportJsonReferentielPorts) | **GET** /v1/referentiels/ports/json | Export json \&quot;referentiel - ports\&quot;
[**ExportJsonReferentielStationsAir**](ReferentielsApi.md#ExportJsonReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/json | Export json \&quot;referentiel - stationsAir\&quot;
[**ExportJsonReferentielStationsEsu**](ReferentielsApi.md#ExportJsonReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/json | Export json \&quot;referentiel - stationsEsu\&quot;
[**ExportJsonReferentielTags**](ReferentielsApi.md#ExportJsonReferentielTags) | **GET** /v1/referentiels/tags/json | Export json \&quot;referentiel - tags\&quot;
[**ExportShapefileReferentielCog**](ReferentielsApi.md#ExportShapefileReferentielCog) | **GET** /v1/referentiels/cog/spatial/shapefile | Export shapefile \&quot;referentiel - cog\&quot;
[**ExportShapefileReferentielStationsAir**](ReferentielsApi.md#ExportShapefileReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/spatial/shapefile | Export shapefile \&quot;referentiel - stationsAir\&quot;
[**ExportShapefileReferentielStationsEsu**](ReferentielsApi.md#ExportShapefileReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/spatial/shapefile | Export shapefile \&quot;referentiel - stationsEsu\&quot;
[**ExportXlsxReferentielCog**](ReferentielsApi.md#ExportXlsxReferentielCog) | **GET** /v1/referentiels/cog/xlsx | Export xlsx \&quot;referentiel - cog\&quot;
[**ExportXlsxReferentielGeozones**](ReferentielsApi.md#ExportXlsxReferentielGeozones) | **GET** /v1/referentiels/geozones/xlsx | Export xlsx \&quot;referentiel - geozones\&quot;
[**ExportXlsxReferentielPolluantsEau**](ReferentielsApi.md#ExportXlsxReferentielPolluantsEau) | **GET** /v1/referentiels/polluantsEau/xlsx | Export xlsx \&quot;referentiel - polluantsEau\&quot;
[**ExportXlsxReferentielPorts**](ReferentielsApi.md#ExportXlsxReferentielPorts) | **GET** /v1/referentiels/ports/xlsx | Export xlsx \&quot;referentiel - ports\&quot;
[**ExportXlsxReferentielStationsAir**](ReferentielsApi.md#ExportXlsxReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/xlsx | Export xlsx \&quot;referentiel - stationsAir\&quot;
[**ExportXlsxReferentielStationsEsu**](ReferentielsApi.md#ExportXlsxReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/xlsx | Export xlsx \&quot;referentiel - stationsEsu\&quot;
[**ExportXlsxReferentielTags**](ReferentielsApi.md#ExportXlsxReferentielTags) | **GET** /v1/referentiels/tags/xlsx | Export xlsx \&quot;referentiel - tags\&quot;
[**GetIdReferentielCog**](ReferentielsApi.md#GetIdReferentielCog) | **GET** /v1/referentiels/cog/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - cog\&quot;
[**GetIdReferentielGeozones**](ReferentielsApi.md#GetIdReferentielGeozones) | **GET** /v1/referentiels/geozones/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - geozones\&quot;
[**GetIdReferentielPolluantsEau**](ReferentielsApi.md#GetIdReferentielPolluantsEau) | **GET** /v1/referentiels/polluantsEau/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - polluantsEau\&quot;
[**GetIdReferentielPorts**](ReferentielsApi.md#GetIdReferentielPorts) | **GET** /v1/referentiels/ports/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - ports\&quot;
[**GetIdReferentielStationsAir**](ReferentielsApi.md#GetIdReferentielStationsAir) | **GET** /v1/referentiels/stationsAir/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - stationsAir\&quot;
[**GetIdReferentielStationsEsu**](ReferentielsApi.md#GetIdReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - stationsEsu\&quot;
[**GetIdReferentielTags**](ReferentielsApi.md#GetIdReferentielTags) | **GET** /v1/referentiels/tags/{id} | Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;referentiel - tags\&quot;
[**PaginateReferentielCog**](ReferentielsApi.md#PaginateReferentielCog) | **GET** /v1/referentiels/cog | Pagination \&quot;referentiel - cog\&quot;
[**PaginateReferentielGeozones**](ReferentielsApi.md#PaginateReferentielGeozones) | **GET** /v1/referentiels/geozones | Pagination \&quot;referentiel - geozones\&quot;
[**PaginateReferentielPolluantsEau**](ReferentielsApi.md#PaginateReferentielPolluantsEau) | **GET** /v1/referentiels/polluantsEau | Pagination \&quot;referentiel - polluantsEau\&quot;
[**PaginateReferentielPorts**](ReferentielsApi.md#PaginateReferentielPorts) | **GET** /v1/referentiels/ports | Pagination \&quot;referentiel - ports\&quot;
[**PaginateReferentielStationsAir**](ReferentielsApi.md#PaginateReferentielStationsAir) | **GET** /v1/referentiels/stationsAir | Pagination \&quot;referentiel - stationsAir\&quot;
[**PaginateReferentielStationsEsu**](ReferentielsApi.md#PaginateReferentielStationsEsu) | **GET** /v1/referentiels/stationsEsu | Pagination \&quot;referentiel - stationsEsu\&quot;
[**PaginateReferentielTags**](ReferentielsApi.md#PaginateReferentielTags) | **GET** /v1/referentiels/tags | Pagination \&quot;referentiel - tags\&quot;


# **ExportCsvReferentielCog**
> character ExportCsvReferentielCog(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Export csv \"referentiel - cog\"

Permet d'obtenir un export csv d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Export csv \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielCog(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielGeozones**
> character ExportCsvReferentielGeozones(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)

Export csv \"referentiel - geozones\"

Permet d'obtenir un export csv d'éléments de \"referentiel - geozones\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export csv \"referentiel - geozones\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielGeozones(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] | Options de tri | [optional] 
 **columns** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielPolluantsEau**
> character ExportCsvReferentielPolluantsEau(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)

Export csv \"referentiel - polluantsEau\"

Permet d'obtenir un export csv d'éléments de \"referentiel - polluantsEau\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin

#Export csv \"referentiel - polluantsEau\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielPolluantsEau(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, UNIT] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UNIT** | **character**| Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielPorts**
> character ExportCsvReferentielPorts(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)

Export csv \"referentiel - ports\"

Permet d'obtenir un export csv d'éléments de \"referentiel - ports\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export csv \"referentiel - ports\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielPorts(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, MCA_CODE, MCA_NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_CODE** | **character**| Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_NAME** | **character**| Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielStationsAir**
> character ExportCsvReferentielStationsAir(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Export csv \"referentiel - stationsAir\"

Permet d'obtenir un export csv d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export csv \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielStationsAir(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielStationsEsu**
> character ExportCsvReferentielStationsEsu(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Export csv \"referentiel - stationsEsu\"

Permet d'obtenir un export csv d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export csv \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielStationsEsu(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportCsvReferentielTags**
> character ExportCsvReferentielTags(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)

Export csv \"referentiel - tags\"

Permet d'obtenir un export csv d'éléments de \"referentiel - tags\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("VALUE") # array[character] | Options de tri
var.columns <- list("VALUE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin

#Export csv \"referentiel - tags\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportCsvReferentielTags(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] | Options de tri | [optional] 
 **columns** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET | [optional] 
 **VALUE** | **character**| Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **DISPLAY** | **character**| Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **TOPICS** | **character**| Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **EUROVOC** | **character**| Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **ECOPLANET** | **character**| Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: text/csv; charset=utf-8, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export csv d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportGeojsonReferentielCog**
> character ExportGeojsonReferentielCog(geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Export geojson \"referentiel - cog\"

Permet d'obtenir un export geojson d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Export geojson \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportGeojsonReferentielCog(var.geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION, AREA] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export geojson d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportGeojsonReferentielStationsAir**
> character ExportGeojsonReferentielStationsAir(geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Export geojson \"referentiel - stationsAir\"

Permet d'obtenir un export geojson d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export geojson \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportGeojsonReferentielStationsAir(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export geojson d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportGeojsonReferentielStationsEsu**
> character ExportGeojsonReferentielStationsEsu(geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Export geojson \"referentiel - stationsEsu\"

Permet d'obtenir un export geojson d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export geojson \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportGeojsonReferentielStationsEsu(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export geojson d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielCog**
> character ExportJsonReferentielCog(order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Export json \"referentiel - cog\"

Permet d'obtenir un export json d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Export json \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielCog(order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielGeozones**
> character ExportJsonReferentielGeozones(order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)

Export json \"referentiel - geozones\"

Permet d'obtenir un export json d'éléments de \"referentiel - geozones\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export json \"referentiel - geozones\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielGeozones(order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] | Options de tri | [optional] 
 **columns** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielPolluantsEau**
> character ExportJsonReferentielPolluantsEau(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)

Export json \"referentiel - polluantsEau\"

Permet d'obtenir un export json d'éléments de \"referentiel - polluantsEau\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin

#Export json \"referentiel - polluantsEau\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielPolluantsEau(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, UNIT] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UNIT** | **character**| Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielPorts**
> character ExportJsonReferentielPorts(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)

Export json \"referentiel - ports\"

Permet d'obtenir un export json d'éléments de \"referentiel - ports\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export json \"referentiel - ports\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielPorts(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, MCA_CODE, MCA_NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_CODE** | **character**| Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_NAME** | **character**| Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielStationsAir**
> character ExportJsonReferentielStationsAir(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Export json \"referentiel - stationsAir\"

Permet d'obtenir un export json d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export json \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielStationsAir(order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielStationsEsu**
> character ExportJsonReferentielStationsEsu(order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Export json \"referentiel - stationsEsu\"

Permet d'obtenir un export json d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export json \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielStationsEsu(order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportJsonReferentielTags**
> character ExportJsonReferentielTags(order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)

Export json \"referentiel - tags\"

Permet d'obtenir un export json d'éléments de \"referentiel - tags\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.order.by <- list("VALUE") # array[character] | Options de tri
var.columns <- list("VALUE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin

#Export json \"referentiel - tags\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportJsonReferentielTags(order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **order.by** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] | Options de tri | [optional] 
 **columns** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET | [optional] 
 **VALUE** | **character**| Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **DISPLAY** | **character**| Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **TOPICS** | **character**| Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **EUROVOC** | **character**| Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **ECOPLANET** | **character**| Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**character**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export json d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportShapefileReferentielCog**
> data.frame ExportShapefileReferentielCog(geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Export shapefile \"referentiel - cog\"

Permet d'obtenir un export shapefile d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Export shapefile \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportShapefileReferentielCog(var.geo.field, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION, AREA] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/zip, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export shapefile d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportShapefileReferentielStationsAir**
> data.frame ExportShapefileReferentielStationsAir(geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Export shapefile \"referentiel - stationsAir\"

Permet d'obtenir un export shapefile d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export shapefile \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportShapefileReferentielStationsAir(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/zip, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export shapefile d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportShapefileReferentielStationsEsu**
> data.frame ExportShapefileReferentielStationsEsu(geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Export shapefile \"referentiel - stationsEsu\"

Permet d'obtenir un export shapefile d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.geo.field <- 'geo.field_example' # character | Champ pivot pour la génération du geojson ou du shapefile
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export shapefile \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportShapefileReferentielStationsEsu(var.geo.field, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **geo.field** | Enum [LOCATION] | Champ pivot pour la génération du geojson ou du shapefile | 
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/zip, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export shapefile d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielCog**
> data.frame ExportXlsxReferentielCog(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Export xlsx \"referentiel - cog\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Export xlsx \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielCog(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielGeozones**
> data.frame ExportXlsxReferentielGeozones(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)

Export xlsx \"referentiel - geozones\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - geozones\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export xlsx \"referentiel - geozones\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielGeozones(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] | Options de tri | [optional] 
 **columns** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielPolluantsEau**
> data.frame ExportXlsxReferentielPolluantsEau(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)

Export xlsx \"referentiel - polluantsEau\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - polluantsEau\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin

#Export xlsx \"referentiel - polluantsEau\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielPolluantsEau(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, UNIT] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UNIT** | **character**| Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielPorts**
> data.frame ExportXlsxReferentielPorts(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)

Export xlsx \"referentiel - ports\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - ports\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin

#Export xlsx \"referentiel - ports\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielPorts(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, MCA_CODE, MCA_NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_CODE** | **character**| Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_NAME** | **character**| Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielStationsAir**
> data.frame ExportXlsxReferentielStationsAir(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Export xlsx \"referentiel - stationsAir\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export xlsx \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielStationsAir(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielStationsEsu**
> data.frame ExportXlsxReferentielStationsEsu(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Export xlsx \"referentiel - stationsEsu\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Export xlsx \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielStationsEsu(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **ExportXlsxReferentielTags**
> data.frame ExportXlsxReferentielTags(with.column.name, with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)

Export xlsx \"referentiel - tags\"

Permet d'obtenir un export xlsx d'éléments de \"referentiel - tags\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.with.column.name <- 'with.column.name_example' # character | faut-il ajouter le nom des colonnes en entête du fichier csv ?
var.with.column.description <- 'with.column.description_example' # character | faut-il ajouter la description des colonnes en entête du fichier csv ?
var.order.by <- list("VALUE") # array[character] | Options de tri
var.columns <- list("VALUE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin

#Export xlsx \"referentiel - tags\"
api.instance <- ReferentielsApi$new()
result <- api.instance$ExportXlsxReferentielTags(var.with.column.name, var.with.column.description, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **with.column.name** | **character**| faut-il ajouter le nom des colonnes en entête du fichier csv ? | 
 **with.column.description** | **character**| faut-il ajouter la description des colonnes en entête du fichier csv ? | 
 **order.by** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] | Options de tri | [optional] 
 **columns** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET | [optional] 
 **VALUE** | **character**| Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **DISPLAY** | **character**| Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **TOPICS** | **character**| Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **EUROVOC** | **character**| Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **ECOPLANET** | **character**| Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

**data.frame**

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec un export xlsx d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielCog**
> ItemCog GetIdReferentielCog(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - cog\"

Permet d'obtenir le détail d'un élément de \"referentiel - cog\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - cog\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielCog(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - cog\&quot; | 

### Return type

[**ItemCog**](item_cog.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielGeozones**
> ItemGeozones GetIdReferentielGeozones(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - geozones\"

Permet d'obtenir le détail d'un élément de \"referentiel - geozones\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - geozones\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - geozones\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielGeozones(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - geozones\&quot; | 

### Return type

[**ItemGeozones**](item_geozones.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielPolluantsEau**
> ItemPolluantsEau GetIdReferentielPolluantsEau(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - polluantsEau\"

Permet d'obtenir le détail d'un élément de \"referentiel - polluantsEau\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - polluantsEau\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - polluantsEau\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielPolluantsEau(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - polluantsEau\&quot; | 

### Return type

[**ItemPolluantsEau**](item_polluantsEau.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielPorts**
> ItemPorts GetIdReferentielPorts(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - ports\"

Permet d'obtenir le détail d'un élément de \"referentiel - ports\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - ports\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - ports\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielPorts(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - ports\&quot; | 

### Return type

[**ItemPorts**](item_ports.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielStationsAir**
> ItemStationsAir GetIdReferentielStationsAir(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - stationsAir\"

Permet d'obtenir le détail d'un élément de \"referentiel - stationsAir\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - stationsAir\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielStationsAir(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - stationsAir\&quot; | 

### Return type

[**ItemStationsAir**](item_stationsAir.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielStationsEsu**
> ItemStationsEsu GetIdReferentielStationsEsu(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - stationsEsu\"

Permet d'obtenir le détail d'un élément de \"referentiel - stationsEsu\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - stationsEsu\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielStationsEsu(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - stationsEsu\&quot; | 

### Return type

[**ItemStationsEsu**](item_stationsEsu.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **GetIdReferentielTags**
> ItemTags GetIdReferentielTags(id)

Détail de l'élément avec l'identifiant :id de \"referentiel - tags\"

Permet d'obtenir le détail d'un élément de \"referentiel - tags\" dont on connaît l'id.

### Example
```R
library(didoscalie)

var.id <- 'id_example' # character | identifiant de l'élement dans \"referentiel - tags\"

#Détail de l'élément avec l'identifiant :id de \"referentiel - tags\"
api.instance <- ReferentielsApi$new()
result <- api.instance$GetIdReferentielTags(var.id)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **id** | **character**| identifiant de l&#39;élement dans \&quot;referentiel - tags\&quot; | 

### Return type

[**ItemTags**](item_tags.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une le détail d&#39;un élément |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielCog**
> PaginateListCog PaginateReferentielCog(page, page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)

Pagination \"referentiel - cog\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - cog\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.TYPE <- 'TYPE_example' # character | Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_MILLESIME <- 'CODE_MILLESIME_example' # character | Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_CURRENT <- 'CODE_CURRENT_example' # character | Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin
var.OFFICIAL_NAME <- 'OFFICIAL_NAME_example' # character | Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UPPER_NAME <- 'UPPER_NAME_example' # character | Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOWER_NAME <- 'LOWER_NAME_example' # character | Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within
var.SHAPE <- 'SHAPE_example' # character | Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SHAPE sont: near, within

#Pagination \"referentiel - cog\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielCog(var.page, var.page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, MILLESIME=var.MILLESIME, TYPE=var.TYPE, LEVEL=var.LEVEL, CODE_MILLESIME=var.CODE_MILLESIME, CODE_CURRENT=var.CODE_CURRENT, OFFICIAL_NAME=var.OFFICIAL_NAME, UPPER_NAME=var.UPPER_NAME, LOWER_NAME=var.LOWER_NAME, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION, SHAPE=var.SHAPE)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE, -ID, -MILLESIME, -TYPE, -LEVEL, -CODE_MILLESIME, -CODE_CURRENT, -OFFICIAL_NAME, -UPPER_NAME, -LOWER_NAME, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, MILLESIME, TYPE, LEVEL, CODE_MILLESIME, CODE_CURRENT, OFFICIAL_NAME, UPPER_NAME, LOWER_NAME, LONGITUDE, LATITUDE | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **TYPE** | **character**| Pour filtrer selon la valeur de TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_MILLESIME** | **character**| Pour filtrer selon la valeur de CODE_MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_MILLESIME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_CURRENT** | **character**| Pour filtrer selon la valeur de CODE_CURRENT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_CURRENT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **OFFICIAL_NAME** | **character**| Pour filtrer selon la valeur de OFFICIAL_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour OFFICIAL_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UPPER_NAME** | **character**| Pour filtrer selon la valeur de UPPER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UPPER_NAME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOWER_NAME** | **character**| Pour filtrer selon la valeur de LOWER_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOWER_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 
 **SHAPE** | **character**| Pour filtrer selon la valeur de SHAPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SHAPE sont: near, within | [optional] 

### Return type

[**PaginateListCog**](paginateList_cog.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielGeozones**
> PaginateListGeozones PaginateReferentielGeozones(page, page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)

Pagination \"referentiel - geozones\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - geozones\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("ID") # array[character] | Options de tri
var.columns <- list("ID") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME
var.ID <- 'ID_example' # character | Pour filtrer selon la valeur de ID. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin
var.LEVEL <- 'LEVEL_example' # character | Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin

#Pagination \"referentiel - geozones\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielGeozones(var.page, var.page.size, order.by=var.order.by, columns=var.columns, ID=var.ID, LEVEL=var.LEVEL, CODE=var.CODE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, NAME=var.NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME, -ID, -LEVEL, -CODE, -VALIDITY_START, -VALIDITY_END, -NAME] | Options de tri | [optional] 
 **columns** | Enum [ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: ID, LEVEL, CODE, VALIDITY_START, VALIDITY_END, NAME | [optional] 
 **ID** | **character**| Pour filtrer selon la valeur de ID. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ID sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LEVEL** | **character**| Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

[**PaginateListGeozones**](paginateList_geozones.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielPolluantsEau**
> PaginateListPolluantsEau PaginateReferentielPolluantsEau(page, page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)

Pagination \"referentiel - polluantsEau\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - polluantsEau\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.UNIT <- 'UNIT_example' # character | Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin

#Pagination \"referentiel - polluantsEau\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielPolluantsEau(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, UNIT=var.UNIT)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [CODE, NAME, UNIT, -CODE, -NAME, -UNIT] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, UNIT] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **UNIT** | **character**| Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

[**PaginateListPolluantsEau**](paginateList_polluantsEau.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielPorts**
> PaginateListPorts PaginateReferentielPorts(page, page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)

Pagination \"referentiel - ports\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - ports\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_CODE <- 'MCA_CODE_example' # character | Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin
var.MCA_NAME <- 'MCA_NAME_example' # character | Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin

#Pagination \"referentiel - ports\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielPorts(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, MCA_CODE=var.MCA_CODE, MCA_NAME=var.MCA_NAME)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [CODE, NAME, MCA_CODE, MCA_NAME, -CODE, -NAME, -MCA_CODE, -MCA_NAME] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, MCA_CODE, MCA_NAME] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, MCA_CODE, MCA_NAME | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_CODE** | **character**| Pour filtrer selon la valeur de MCA_CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MCA_NAME** | **character**| Pour filtrer selon la valeur de MCA_NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MCA_NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

[**PaginateListPorts**](paginateList_ports.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielStationsAir**
> PaginateListStationsAir PaginateReferentielStationsAir(page, page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)

Pagination \"referentiel - stationsAir\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - stationsAir\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.NAME <- 'NAME_example' # character | Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin
var.CODE_ZAS <- 'CODE_ZAS_example' # character | Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.NAME_ZAS <- 'NAME_ZAS_example' # character | Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin
var.COMMUNE <- 'COMMUNE_example' # character | Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin
var.AASQA <- 'AASQA_example' # character | Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.ALTITUDE <- 'ALTITUDE_example' # character | Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_START <- 'VALIDITY_START_example' # character | Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin
var.VALIDITY_END <- 'VALIDITY_END_example' # character | Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin
var.SECTOR_TYPE <- 'SECTOR_TYPE_example' # character | Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin
var.MILLESIME <- 'MILLESIME_example' # character | Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin
var.impact.pm10 <- 'impact.pm10_example' # character | Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.no2 <- 'impact.no2_example' # character | Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.o3 <- 'impact.o3_example' # character | Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.so2 <- 'impact.so2_example' # character | Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin
var.impact.pm25 <- 'impact.pm25_example' # character | Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin
var.IMPACT_CO <- 'IMPACT_CO_example' # character | Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Pagination \"referentiel - stationsAir\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielStationsAir(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, NAME=var.NAME, CODE_ZAS=var.CODE_ZAS, NAME_ZAS=var.NAME_ZAS, COMMUNE=var.COMMUNE, AASQA=var.AASQA, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, ALTITUDE=var.ALTITUDE, VALIDITY_START=var.VALIDITY_START, VALIDITY_END=var.VALIDITY_END, SECTOR_TYPE=var.SECTOR_TYPE, MILLESIME=var.MILLESIME, impact.pm10=var.impact.pm10, impact.no2=var.impact.no2, impact.o3=var.impact.o3, impact.so2=var.impact.so2, impact.pm25=var.impact.pm25, IMPACT_CO=var.IMPACT_CO, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO, -CODE, -NAME, -CODE_ZAS, -NAME_ZAS, -COMMUNE, -AASQA, -LONGITUDE, -LATITUDE, -ALTITUDE, -VALIDITY_START, -VALIDITY_END, -SECTOR_TYPE, -MILLESIME, -IMPACT_PM10, -IMPACT_NO2, -IMPACT_O3, -IMPACT_SO2, -IMPACT_PM25, -IMPACT_CO] | Options de tri | [optional] 
 **columns** | Enum [CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, CODE_ZAS, NAME_ZAS, COMMUNE, AASQA, LONGITUDE, LATITUDE, ALTITUDE, VALIDITY_START, VALIDITY_END, SECTOR_TYPE, MILLESIME, IMPACT_PM10, IMPACT_NO2, IMPACT_O3, IMPACT_SO2, IMPACT_PM25, IMPACT_CO | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME** | **character**| Pour filtrer selon la valeur de NAME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **CODE_ZAS** | **character**| Pour filtrer selon la valeur de CODE_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **NAME_ZAS** | **character**| Pour filtrer selon la valeur de NAME_ZAS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour NAME_ZAS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **COMMUNE** | **character**| Pour filtrer selon la valeur de COMMUNE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour COMMUNE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **AASQA** | **character**| Pour filtrer selon la valeur de AASQA. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour AASQA sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **ALTITUDE** | **character**| Pour filtrer selon la valeur de ALTITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ALTITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_START** | **character**| Pour filtrer selon la valeur de VALIDITY_START. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_START sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **VALIDITY_END** | **character**| Pour filtrer selon la valeur de VALIDITY_END. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALIDITY_END sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **SECTOR_TYPE** | **character**| Pour filtrer selon la valeur de SECTOR_TYPE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour SECTOR_TYPE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **MILLESIME** | **character**| Pour filtrer selon la valeur de MILLESIME. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour MILLESIME sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **impact.pm10** | **character**| Pour filtrer selon la valeur de IMPACT_PM10. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM10 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.no2** | **character**| Pour filtrer selon la valeur de IMPACT_NO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_NO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.o3** | **character**| Pour filtrer selon la valeur de IMPACT_O3. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_O3 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.so2** | **character**| Pour filtrer selon la valeur de IMPACT_SO2. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_SO2 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **impact.pm25** | **character**| Pour filtrer selon la valeur de IMPACT_PM25. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_PM25 sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **IMPACT_CO** | **character**| Pour filtrer selon la valeur de IMPACT_CO. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour IMPACT_CO sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

[**PaginateListStationsAir**](paginateList_stationsAir.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielStationsEsu**
> PaginateListStationsEsu PaginateReferentielStationsEsu(page, page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)

Pagination \"referentiel - stationsEsu\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - stationsEsu\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("CODE") # array[character] | Options de tri
var.columns <- list("CODE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE
var.CODE <- 'CODE_example' # character | Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin
var.LONGITUDE <- 'LONGITUDE_example' # character | Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LATITUDE <- 'LATITUDE_example' # character | Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin
var.LOCATION <- 'LOCATION_example' # character | Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LOCATION sont: near, within

#Pagination \"referentiel - stationsEsu\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielStationsEsu(var.page, var.page.size, order.by=var.order.by, columns=var.columns, CODE=var.CODE, LONGITUDE=var.LONGITUDE, LATITUDE=var.LATITUDE, LOCATION=var.LOCATION)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [CODE, LONGITUDE, LATITUDE, -CODE, -LONGITUDE, -LATITUDE] | Options de tri | [optional] 
 **columns** | Enum [CODE, LONGITUDE, LATITUDE] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, LONGITUDE, LATITUDE | [optional] 
 **CODE** | **character**| Pour filtrer selon la valeur de CODE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **LONGITUDE** | **character**| Pour filtrer selon la valeur de LONGITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LONGITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LATITUDE** | **character**| Pour filtrer selon la valeur de LATITUDE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LATITUDE sont: eq, ne, gt, gte, lt, lte, in, nin | [optional] 
 **LOCATION** | **character**| Pour filtrer selon la valeur de LOCATION. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour LOCATION sont: near, within | [optional] 

### Return type

[**PaginateListStationsEsu**](paginateList_stationsEsu.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

# **PaginateReferentielTags**
> PaginateListTags PaginateReferentielTags(page, page.size, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)

Pagination \"referentiel - tags\"

Permet d'obtenir une liste paginée d'éléments de \"referentiel - tags\". Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.

### Example
```R
library(didoscalie)

var.page <- 56 # integer | Numéro de la page à afficher
var.page.size <- 'page.size_example' # character | Nombre de lignes par page
var.order.by <- list("VALUE") # array[character] | Options de tri
var.columns <- list("VALUE") # array[character] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET
var.VALUE <- 'VALUE_example' # character | Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin
var.DISPLAY <- 'DISPLAY_example' # character | Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin
var.TOPICS <- 'TOPICS_example' # character | Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin
var.EUROVOC <- 'EUROVOC_example' # character | Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin
var.ECOPLANET <- 'ECOPLANET_example' # character | Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin

#Pagination \"referentiel - tags\"
api.instance <- ReferentielsApi$new()
result <- api.instance$PaginateReferentielTags(var.page, var.page.size, order.by=var.order.by, columns=var.columns, VALUE=var.VALUE, DISPLAY=var.DISPLAY, TOPICS=var.TOPICS, EUROVOC=var.EUROVOC, ECOPLANET=var.ECOPLANET)
dput(result)
```

### Parameters

Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **page** | **integer**| Numéro de la page à afficher | 
 **page.size** | Enum [10, 20, 50, 100] | Nombre de lignes par page | 
 **order.by** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET, -VALUE, -DISPLAY, -TOPICS, -EUROVOC, -ECOPLANET] | Options de tri | [optional] 
 **columns** | Enum [VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET] | Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: VALUE, DISPLAY, TOPICS, EUROVOC, ECOPLANET | [optional] 
 **VALUE** | **character**| Pour filtrer selon la valeur de VALUE. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour VALUE sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **DISPLAY** | **character**| Pour filtrer selon la valeur de DISPLAY. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour DISPLAY sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **TOPICS** | **character**| Pour filtrer selon la valeur de TOPICS. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour TOPICS sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **EUROVOC** | **character**| Pour filtrer selon la valeur de EUROVOC. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour EUROVOC sont: eq, ne, startsWith, endsWith, in, nin | [optional] 
 **ECOPLANET** | **character**| Pour filtrer selon la valeur de ECOPLANET. Le format doit être de la forme \&quot;typeFiltre:valeurFiltre\&quot;. Les types de filtres disponibles pour ECOPLANET sont: eq, ne, startsWith, endsWith, in, nin | [optional] 

### Return type

[**PaginateListTags**](paginateList_tags.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details
| Status code | Description | Response headers |
|-------------|-------------|------------------|
| **200** | Réponse avec une liste paginée d&#39;éléments |  -  |
| **400** | Réponse dans le cas d&#39;une erreur de validation |  -  |
| **404** | Réponse si élément non trouvé |  -  |
| **500** | Réponse si erreur interne au serveur |  -  |

