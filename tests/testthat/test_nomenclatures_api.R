# Automatically generated by openapi-generator (https://openapi-generator.tech)
# Please update as you see appropriate

context("Test NomenclaturesApi")

api.instance <- NomenclaturesApi$new()

test_that("ExportCsvNomenclatureBilanEnergie", {
  # tests for ExportCsvNomenclatureBilanEnergie
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export csv \&quot;nomenclature - bilanEnergie\&quot;
  # Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param UNIT character Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param LEVEL character Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param DATA_TYPE character Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param FLOW_TYPE character Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportCsvNomenclatureCslFilieres", {
  # tests for ExportCsvNomenclatureCslFilieres
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export csv \&quot;nomenclature - cslFilieres\&quot;
  # Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportCsvNomenclatureCslOperations", {
  # tests for ExportCsvNomenclatureCslOperations
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export csv \&quot;nomenclature - cslOperations\&quot;
  # Permet d&#39;obtenir un export csv d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4 (optional)
  # @param code.1 character Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.1 character Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.2 character Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.2 character Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.3 character Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.3 character Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.4 character Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.4 character Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportJsonNomenclatureBilanEnergie", {
  # tests for ExportJsonNomenclatureBilanEnergie
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export json \&quot;nomenclature - bilanEnergie\&quot;
  # Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param UNIT character Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param LEVEL character Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param DATA_TYPE character Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param FLOW_TYPE character Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportJsonNomenclatureCslFilieres", {
  # tests for ExportJsonNomenclatureCslFilieres
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export json \&quot;nomenclature - cslFilieres\&quot;
  # Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportJsonNomenclatureCslOperations", {
  # tests for ExportJsonNomenclatureCslOperations
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export json \&quot;nomenclature - cslOperations\&quot;
  # Permet d&#39;obtenir un export json d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4 (optional)
  # @param code.1 character Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.1 character Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.2 character Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.2 character Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.3 character Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.3 character Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.4 character Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.4 character Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [character]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportXlsxNomenclatureBilanEnergie", {
  # tests for ExportXlsxNomenclatureBilanEnergie
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export xlsx \&quot;nomenclature - bilanEnergie\&quot;
  # Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param UNIT character Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param LEVEL character Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param DATA_TYPE character Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param FLOW_TYPE character Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportXlsxNomenclatureCslFilieres", {
  # tests for ExportXlsxNomenclatureCslFilieres
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export xlsx \&quot;nomenclature - cslFilieres\&quot;
  # Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("ExportXlsxNomenclatureCslOperations", {
  # tests for ExportXlsxNomenclatureCslOperations
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Export xlsx \&quot;nomenclature - cslOperations\&quot;
  # Permet d&#39;obtenir un export xlsx d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param with.column.name character faut-il ajouter le nom des colonnes en entête du fichier csv ?
  # @param with.column.description character faut-il ajouter la description des colonnes en entête du fichier csv ?
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4 (optional)
  # @param code.1 character Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.1 character Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.2 character Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.2 character Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.3 character Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.3 character Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.4 character Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.4 character Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [data.frame]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("GetIdNomenclatureBilanEnergie", {
  # tests for GetIdNomenclatureBilanEnergie
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - bilanEnergie\&quot;
  # Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - bilanEnergie\&quot; dont on connaît l&#39;id.
  # @param id character identifiant de l'élement dans \"nomenclature - bilanEnergie\"
  # @return [ItemBilanEnergie]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("GetIdNomenclatureCslFilieres", {
  # tests for GetIdNomenclatureCslFilieres
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - cslFilieres\&quot;
  # Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - cslFilieres\&quot; dont on connaît l&#39;id.
  # @param id character identifiant de l'élement dans \"nomenclature - cslFilieres\"
  # @return [ItemCslFilieres]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("GetIdNomenclatureCslOperations", {
  # tests for GetIdNomenclatureCslOperations
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Détail de l&#39;élément avec l&#39;identifiant :id de \&quot;nomenclature - cslOperations\&quot;
  # Permet d&#39;obtenir le détail d&#39;un élément de \&quot;nomenclature - cslOperations\&quot; dont on connaît l&#39;id.
  # @param id character identifiant de l'élement dans \"nomenclature - cslOperations\"
  # @return [ItemCslOperations]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("PaginateNomenclatureBilanEnergie", {
  # tests for PaginateNomenclatureBilanEnergie
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Pagination \&quot;nomenclature - bilanEnergie\&quot;
  # Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - bilanEnergie\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param page integer Numéro de la page à afficher
  # @param page.size character Nombre de lignes par page
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME, UNIT, LEVEL, DATA_TYPE, FLOW_TYPE (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param UNIT character Pour filtrer selon la valeur de UNIT. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour UNIT sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param LEVEL character Pour filtrer selon la valeur de LEVEL. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour LEVEL sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param DATA_TYPE character Pour filtrer selon la valeur de DATA_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour DATA_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param FLOW_TYPE character Pour filtrer selon la valeur de FLOW_TYPE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour FLOW_TYPE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [PaginateListBilanEnergie]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("PaginateNomenclatureCslFilieres", {
  # tests for PaginateNomenclatureCslFilieres
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Pagination \&quot;nomenclature - cslFilieres\&quot;
  # Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - cslFilieres\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param page integer Numéro de la page à afficher
  # @param page.size character Nombre de lignes par page
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE, NAME (optional)
  # @param CODE character Pour filtrer selon la valeur de CODE. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param NAME character Pour filtrer selon la valeur de NAME. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [PaginateListCslFilieres]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

test_that("PaginateNomenclatureCslOperations", {
  # tests for PaginateNomenclatureCslOperations
  # base path: https://data.statistiques.developpement-durable.gouv.fr/dido/api
  # Pagination \&quot;nomenclature - cslOperations\&quot;
  # Permet d&#39;obtenir une liste paginée d&#39;éléments de \&quot;nomenclature - cslOperations\&quot;. Il est possible de trier, filtrer et sélectionner les colonnes souhaitées.
  # @param page integer Numéro de la page à afficher
  # @param page.size character Nombre de lignes par page
  # @param order.by array[character] Options de tri (optional)
  # @param columns array[character] Liste des colonnes à inclure dans le résultat. Les colonnes doivent être saisies en séparant chaque valeur par une virgule. La liste des colonnes disponibles est la suivante: CODE_1, NAME_1, CODE_2, NAME_2, CODE_3, NAME_3, CODE_4, NAME_4 (optional)
  # @param code.1 character Pour filtrer selon la valeur de CODE_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.1 character Pour filtrer selon la valeur de NAME_1. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_1 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.2 character Pour filtrer selon la valeur de CODE_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.2 character Pour filtrer selon la valeur de NAME_2. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_2 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.3 character Pour filtrer selon la valeur de CODE_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.3 character Pour filtrer selon la valeur de NAME_3. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_3 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param code.4 character Pour filtrer selon la valeur de CODE_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour CODE_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @param name.4 character Pour filtrer selon la valeur de NAME_4. Le format doit être de la forme \"typeFiltre:valeurFiltre\". Les types de filtres disponibles pour NAME_4 sont: eq, ne, startsWith, endsWith, in, nin (optional)
  # @return [PaginateListCslOperations]

  # uncomment below to test the operation
  #expect_equal(result, "EXPECTED_RESULT")
})

